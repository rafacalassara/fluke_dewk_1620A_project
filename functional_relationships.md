# Functional Relationships

This document maps user actions to system processes and outcomes based on the code analysis.

| User Action                     | Components Involved                                  | Process                                                                 | Data Flow                                      | Outcome / User Feedback                     | Analysis Batch |
| :------------------------------ | :--------------------------------------------------- | :---------------------------------------------------------------------- | :--------------------------------------------- | :------------------------------------------ | :------------- |
| *Example: Click 'Connect'*      | *`main.js`, `DataConsumer`, `views.connect_instrument`* | *JS sends WebSocket msg. Consumer calls view. View attempts connection.* | *Instrument ID (WS msg). Connection status.* | *UI updates: 'Connecting...' then 'Connected' or 'Error'.* | *Batch 3*      |
| *(Action description)*          | *(List files, functions, classes, templates)*        | *(Describe internal steps)*                                             | *(Describe data movement and format)*           | *(Describe visible result or state change)* | *(Batch #)*    |
| System Startup/Background Connection | `Instrument`, `Thermohygrometer`, `ThermohygrometerModel`, `SensorModel`, `visa_communication.py`, `thermohygrometer.py`, `models.py`, PyVISA | `Instrument` instantiated with IP. Connects via VISA (`Thermohygrometer.connect`), gets ID (`get_instrument_personal_info`), updates/creates `ThermohygrometerModel` & default `SensorModel`s (`save_to_database`). Updates instrument clock if needed (`_update_date_time`). | IP Address -> `Instrument`. VISA commands/responses. Instrument details (PN, SN, Name) -> DB (`ThermohygrometerModel`). Default sensor data -> DB (`SensorModel`). | Instrument object created, VISA connection established (or error logged), DB records updated/created. Instrument clock potentially synced. | Batch 1 |
| Establish Real-time Data WebSocket (Control) | Frontend JS (Batch 3), `routing.py`, `DataConsumer`, `Instrument`, `ThermohygrometerModel`, `SensorModel`, `models.py`, `consumers.py`, `visa_communication.py` | 1. JS opens WS to `ws/data/<thermo_id>/`. 2. `routing.py` -> `DataConsumer`. 3. `DataConsumer.connect` gets `ThermohygrometerModel`. 4. Instantiates `Instrument` (connects via VISA). 5. If success: updates `ThermohygrometerModel.is_connected=True`, adds consumer to channel group, accepts WS, sends 'Connecting...', starts `send_data_loop`. 6. If fail: sends 'Failed...' and closes. | `thermo_id` (URL) -> `DataConsumer`. Instrument IP (DB) -> `Instrument`. Connection status (bool) -> DB. WS messages ('Connecting...', 'Failed...'). | WebSocket connection established (or fails). Instrument connected via VISA. `is_connected` flag updated in DB. `send_data_loop` starts polling. | Batch 1 |
| Receive Real-time Data (Polling Loop) | `DataConsumer`, `Instrument`, `SensorModel`, `CalibrationCertificateModel`, `MeasuresModel`, `consumers.py`, `visa_communication.py`, `models.py` | 1. `send_data_loop` runs every 5s. 2. Calls `instrument.get_live_data_all_channels()` (VISA `READ?`). 3. For each sensor: Processes data (applies calibration, determines style), broadcasts processed data via Channel Layer, saves to `MeasuresModel` if interval elapsed. | VISA commands/responses. Raw measurements. Calibration data (DB) -> Corrections. Processed data (dict) -> Channel Layer. Processed data -> `MeasuresModel` (DB). | Instrument polled. Data processed, corrected, styled. Data broadcasted to listeners. Data saved to DB periodically. | Batch 1 |
| Establish Real-time Data WebSocket (Listener) | Frontend JS (Batch 3/4), `routing.py`, `ListenerConsumer`, `consumers.py` | 1. JS opens WS to `ws/listener/<thermo_id>/[sensor/<sensor_id>/]`. 2. `routing.py` -> `ListenerConsumer`. 3. `ListenerConsumer.connect` determines channel group name from URL. 4. Adds consumer to group. 5. Accepts WS connection. | `thermo_id`, `sensor_id` (URL) -> `ListenerConsumer`. | WebSocket connection established. Client subscribed to receive data broadcasts for the instrument/sensor. | Batch 1 |
| Receive Real-time Data (Listener) | `DataConsumer`, `ListenerConsumer`, Frontend JS (Batch 3/4), `consumers.py` | 1. `DataConsumer.broadcast_data` sends data to channel group(s). 2. Channel layer delivers message to subscribed `ListenerConsumer`. 3. `ListenerConsumer.send_data_to_listeners` forwards message over WS to client. | Processed data (JSON) -> Channel Layer -> `ListenerConsumer` -> WebSocket -> Frontend JS. | Frontend JS receives live, processed data updates. | Batch 1 |
| Disconnect Real-time Data WebSocket (Control) | Frontend JS (Batch 3), `DataConsumer`, `Instrument`, `ThermohygrometerModel`, `consumers.py`, `visa_communication.py`, `models.py` | 1. Client sends `disconnect` command or WS closes. 2. `DataConsumer.receive` or `DataConsumer.disconnect` triggered. 3. `disconnect` stops loop (`running=False`), calls `instrument.disconnect()` (closes VISA), removes from group, updates `ThermohygrometerModel.is_connected=False`. | Disconnect command (WS) or close event. Connection status (bool) -> DB. | Polling loop stops. VISA connection closed. WebSocket closed. `is_connected` flag updated in DB. | Batch 1 |
| User Login (Display Form) | `/login/` URL, `urls.py`, `views.LoginView`, `forms.CustomLoginForm`, `templates/fluke_data/login.html` | 1. User navigates to `/login/`. 2. `urls.py` maps to `LoginView`. 3. `LoginView` (GET) renders `login.html` with an empty `CustomLoginForm`. | HTTP GET request. | Login page with username/password fields is displayed. | Batch 2 |
| User Login (Submit Credentials) | `/login/` URL, `urls.py`, `views.LoginView`, `forms.CustomLoginForm`, Django Auth | 1. User submits username/password. 2. `LoginView` (POST) validates data with `CustomLoginForm`. 3. If valid: `login()` function called, user session created, redirect to `/` (`real_time_data`). 4. If invalid: Re-renders `login.html` with form errors. | HTTP POST request (username, password). Session cookie set on success. | User logged in and redirected to dashboard, or login page shown with errors. | Batch 2 |
| View Real-time Dashboard Page | `/` URL, `urls.py`, `views.RealTimeDataView`, `templates/fluke_data/real_time_data.html`, `LoginRequiredMixin`, `ManagerRequiredMixin` | 1. Logged-in manager navigates to `/`. 2. `urls.py` maps to `RealTimeDataView`. 3. Mixins verify authentication and manager status. 4. `RealTimeDataView` renders `real_time_data.html`. | HTTP GET request. User session data (for auth check). | Base HTML structure for the real-time dashboard is rendered. Dynamic content loading expected via JS (Batch 3). | Batch 2 |
| View Instrument List | `/manage-thermohygrometers/` URL, `urls.py`, `views.ManageThermohygrometersView`, `models.ThermohygrometerModel`, `templates/fluke_data/manage_thermohygrometers.html`, `LoginRequiredMixin`, `ManagerRequiredMixin` | 1. Logged-in manager navigates to URL. 2. `urls.py` maps to `ManageThermohygrometersView`. 3. Mixins verify auth. 4. View fetches all `ThermohygrometerModel` objects. 5. Renders template with `thermohygrometers` context. | HTTP GET request. User session data (auth). DB query -> List of instruments -> Template context. | Page displaying a table or list of configured thermohygrometers. | Batch 2 |
| Edit Instrument (Display Form) | `/update-thermohygrometer/<id>/` URL, `urls.py`, `views.UpdateThermohygrometerView`, `models.ThermohygrometerModel`, `forms.ThermohygrometerForm`, `templates/fluke_data/thermohygrometer/update_thermohygrometer.html`, `LoginRequiredMixin`, `ManagerRequiredMixin` | 1. Logged-in manager navigates to URL. 2. `urls.py` maps to `UpdateThermohygrometerView`. 3. Mixins verify auth. 4. View fetches instrument by ID. 5. Renders template with pre-filled `ThermohygrometerForm`. | HTTP GET request. Instrument ID (URL). User session data (auth). DB query -> Instrument object -> Form initial data -> Template context. | Page displaying a form pre-filled with the selected instrument's details. | Batch 2 |
| Edit Instrument (Submit Form) | `/update-thermohygrometer/<id>/` URL, `urls.py`, `views.UpdateThermohygrometerView`, `models.ThermohygrometerModel`, `forms.ThermohygrometerForm`, `LoginRequiredMixin`, `ManagerRequiredMixin` | 1. User submits the edit form. 2. `UpdateThermohygrometerView` (POST) validates data with `ThermohygrometerForm`. 3. If valid: Updates instrument in DB, shows success message, redirects to `manage_thermohygrometers`. 4. If invalid: Re-renders form with errors. | HTTP POST request (form data). Instrument ID (URL). User session data (auth). Form data -> DB update. | Instrument record updated in DB, user redirected to list view with success message, or edit form shown again with errors. | Batch 2 |
| Load Real-time Page & Populate Instruments | `/` URL, `views.RealTimeDataView`, `templates/fluke_data/real_time_data.html`, `static/js/main.js`, `/api/v1/thermohygrometers/` API | 1. User navigates to `/`. 2. `RealTimeDataView` renders template. 3. `main.js` (`DOMContentLoaded`) fetches instrument list from API. 4. JS populates `#thermohygrometer` dropdown. | HTTP GET `/`. HTTP GET `/api/v1/thermohygrometers/`. API response (JSON list) -> JS -> HTML dropdown options. | Real-time dashboard page displayed with instrument selection dropdown populated. | Batch 3 |
| Connect to Single Instrument (UI) | `real_time_data.html` ('Connect' button), `static/js/main.js` (`addThermohygrometer`, `createWebSocket`), `ws/data/<thermo_id>/` endpoint (`DataConsumer`) | 1. User selects instrument, clicks 'Connect'. 2. `addThermohygrometer` checks if already connected. 3. Creates sidebar card (`#connection-card-<id>`) with 'Connecting...' status. 4. `createWebSocket` opens WebSocket connection. 5. `ws.onopen` updates card to 'Connected' (green), adds 'Disconnect' button. | Instrument ID (dropdown value) -> JS. WebSocket handshake. WS `onopen` event. | Sidebar card created. WebSocket connection established (or fails). Card status updated. | Batch 3 |
| Connect to All Instruments (UI) | `real_time_data.html` ('Initialize All' button), `static/js/main.js` (`initializeAllInstruments`, `addThermohygrometer`) | 1. User clicks 'Initialize All'. 2. `initializeAllInstruments` loops through dropdown options. 3. Calls `addThermohygrometer` for each instrument not already connected. | Click event. Loop through dropdown values -> Multiple calls to `addThermohygrometer`. | Connection process initiated for all available, unconnected instruments. Sidebar cards created/updated. | Batch 3 |
| Receive & Display Sensor Data (UI) | WebSocket (`DataConsumer`), `static/js/main.js` (`ws.onmessage`) | 1. `DataConsumer` broadcasts data. 2. `main.js` `ws.onmessage` receives JSON. 3. Parses data (measurements, limits, styles, info). 4. Finds/creates sensor box (`#sensor-<id>`) in `#result-container`. 5. Updates sensor box HTML with data, applying styles. Updates inactivity timer. | WebSocket message (JSON) -> JS. Parsed data -> HTML content/style updates. | Sensor boxes in the main area are created/updated with live data and status colors. | Batch 3 |
| Handle WebSocket Error/Close (Reconnect UI) | WebSocket, `static/js/main.js` (`ws.onerror`, `ws.onclose`, `handleReconnection`) | 1. WebSocket error or close occurs. 2. `handleReconnection` updates sidebar card to 'Reconnecting...' (red). 3. Attempts `createWebSocket` again after delay (up to max attempts). 4. If fails permanently, updates card to 'Connection failed', adds 'Remove' button. | WS error/close event. Reconnect attempts. | Sidebar card status updated to reflect connection state (reconnecting, failed). | Batch 3 |
| Handle Manual Disconnect (UI) | `real_time_data.html` ('Disconnect' button), `static/js/main.js` (`closeConnection`) | 1. User clicks 'Disconnect' on a sidebar card. 2. `closeConnection` sends `disconnect` command via WS (if open). 3. Closes WS locally. 4. Updates card to 'Disconnected' (red), adds 'Remove' button. 5. Removes associated sensor boxes from main area. | Click event -> Instrument ID -> JS. WS `disconnect` command. | WebSocket closed. Sidebar card updated. Sensor boxes removed. | Batch 3 |
| Handle Connection Removal (UI) | `real_time_data.html` ('Remove' button), `static/js/main.js` (`removeInstrument`) | 1. User clicks 'Remove' on a sidebar card (after failure/disconnect). 2. `removeInstrument` removes the sidebar card. 3. Removes associated sensor boxes. 4. Removes connection reference from JS. 5. Shows 'No instruments' message if sidebar becomes empty. | Click event -> Instrument ID -> JS. | Sidebar card and sensor boxes removed from UI. | Batch 3 |
| Handle Inactivity Timeout (UI) | `static/js/main.js` (`setInterval`, `closeConnection`, `addThermohygrometer`) | 1. `setInterval` checks `lastMeasurementTimes`. 2. If timeout detected (>15 mins), calls `closeConnection`. 3. Attempts reconnection via `addThermohygrometer` after a delay. | Timer event. Internal JS state (`lastMeasurementTimes`). | Stale connection closed. Sidebar card updated. Reconnection attempted. | Batch 3 |
| Handle Zero Measurement Anomaly (UI) | `static/js/main.js` (`ws.onmessage`, `closeConnection`, `addThermohygrometer`) | 1. `ws.onmessage` receives data with raw temp/humidity = 0. 2. JS detects anomaly, calls `closeConnection`. 3. Attempts reconnection via `addThermohygrometer` after a delay. | WebSocket message (JSON) -> JS check. | Suspect connection closed. Sidebar card updated. Reconnection attempted. | Batch 3 |
| View Historical Data Page (Initial Load) | `/data-visualization/` URL (Assumed), `urls.py`, `views.DataVisualizationView`, `models.SensorModel`, `templates/fluke_data/data_visualization.html` | 1. User navigates to URL. 2. `urls.py` maps to `DataVisualizationView`. 3. View (GET) fetches all `SensorModel` objects. 4. Renders `data_visualization.html` with `sensors` context. | HTTP GET request. DB query -> List of all sensors -> Template context. | Page displayed with a dropdown list of all available sensors and date/time input fields. | Batch 4 |
| Submit Historical Data Query | `/data-visualization/` URL (Assumed), `views.DataVisualizationView`, `models.SensorModel`, `models.MeasuresModel`, `templates/fluke_data/data_visualization.html` | 1. User selects sensor, date/time range, clicks Submit. 2. `DataVisualizationView` (POST) receives form data. 3. Parses dates/times. 4. Fetches selected `SensorModel`. 5. Queries `MeasuresModel` for data within range for the sensor. 6. Calculates Min/Max/Avg statistics. 7. Re-renders template with `data`, `stats`, `selected_sensor`, and form parameters in context. | HTTP POST request (sensor_id, start_date, start_time, end_date, end_time). DB query (Sensor) -> Sensor object. DB query (Measures) -> Filtered measurements. Aggregation results -> `stats`. Context -> Template. | Page reloads, displaying selected sensor info, statistics table, and data table for the specified period below the form. | Batch 4 |
| Export Historical Data to CSV | `templates/fluke_data/data_visualization.html` (JS `exportToCSV`), `/api/v1/export/export-to-csv/` API endpoint (handled by `api.views.export_data.ExportDataView` - *Inferred*) | 1. User clicks "Export to CSV" button (after submitting a query). 2. JS function `exportToCSV` executes. 3. Sends async POST request to API endpoint with sensor ID and date/time range. 4. API endpoint generates CSV data. 5. JS receives response as Blob, creates download link, triggers download. | Click event -> JS. POST request (JSON: sensor_id, date/time range) -> API endpoint. API response (CSV data as Blob) -> JS -> Browser download. | Browser prompts user to save a CSV file containing the measurement data for the selected sensor and time range. | Batch 4 |
| *Display Live Sensor Data (Separate Feature)* | `static/js/display_measures.js`, `/api/v1/thermohygrometers/connected/` API, `ws/listener/<thermo_id>/` endpoint (`ListenerConsumer`) | *(Note: This JS file seems misplaced in Batch 4)* 1. JS fetches list of connected instruments from API. 2. For each connected instrument, opens WebSocket to `ws/listener/<thermo_id>/`. 3. `ws.onmessage` receives live data broadcasts (originated from `DataConsumer`). 4. JS updates/creates sensor display boxes in the HTML (`#measures-container`). Sorts boxes by location. | HTTP GET `/api/v1/thermohygrometers/connected/`. API Response (JSON list). WebSocket handshake. WebSocket messages (JSON data) -> JS -> HTML updates. | A dedicated page (likely `display_measures.html`) shows dynamically updated boxes with live readings for all sensors on currently connected instruments. | Batch 4 (Misplaced) |
| Server Startup (ASGI) | `manage.py`, `fluke_project/settings.py`, `fluke_project/asgi.py`, `fluke_project/urls.py`, `fluke_data/routing.py` | 1. `manage.py runserver` (or ASGI server command) executed. 2. Loads `settings.py`. 3. Uses `asgi.py` to create `ProtocolTypeRouter`. 4. Router directs HTTP traffic via Django's ASGI app and root `urls.py`. 5. Router directs WebSocket traffic via `AuthMiddlewareStack` to `fluke_data.routing.websocket_urlpatterns`. | Command line -> `manage.py`. Settings -> ASGI app. HTTP request -> Django views. WS connection -> Channels routing. | ASGI server starts, ready to handle HTTP requests and WebSocket connections according to defined routes. | Batch 5 |
| Root URL Routing | Request to `/`, `fluke_project/urls.py`, `fluke_data/urls.py` | 1. HTTP request arrives at server root. 2. `fluke_project/urls.py` matches the empty path (`''`). 3. Uses `include('fluke_data.urls')` to delegate routing to `fluke_data/urls.py`. | HTTP request path. | Request is passed to the `fluke_data` app's URL configuration for further matching. | Batch 5 |
| WebSocket Connection Routing | WebSocket connection attempt, `fluke_project/asgi.py`, `fluke_data/routing.py`, `fluke_data/consumers.py` | 1. Client attempts WebSocket connection. 2. `asgi.py`'s `ProtocolTypeRouter` identifies 'websocket' protocol. 3. Passes connection through `AuthMiddlewareStack`. 4. `URLRouter` uses `fluke_data.routing.websocket_urlpatterns` to match the WS URL path. 5. Connection is routed to the appropriate `Consumer` class in `consumers.py`. | WebSocket URL path. | Connection is accepted/rejected by the matched Consumer, which handles further communication. | Batch 5 |
| Background Instrument Connection (Potential/Inactive) | `fluke_data/connection_manager.py`, `fluke_data/models.py`, `fluke_data/visa_communication.py`, `fluke_project/settings.py` | *(Note: Startup trigger not found in this batch, AUTO_CONNECT_ON_STARTUP=False)* 1. (If started) `connect_all_instruments` loop runs. 2. Fetches all `ThermohygrometerModel`s. 3. Calls `connect_to_instrument` for each. 4. `connect_to_instrument` creates `Instrument` (VISA), updates DB (`is_connected=True`), starts `send_data_loop`. 5. `send_data_loop` polls instrument, sends data via Channels. | DB query -> Instrument list. Instrument IP -> VISA connection. Connection status -> DB update. Instrument data -> Channels group. | Instruments potentially connect automatically, status updated in DB, live data polled and broadcast via Channels. | Batch 5 |
| View Intelligence Page (Initial Load) | `/intelligence/` URL (Assumed), `urls.py`, `views.IntelligenceView`, `forms.EnvironmentalAnalysisForm`, `templates/fluke_data/intelligence.html` | 1. User navigates to URL. 2. `urls.py` maps to `IntelligenceView`. 3. View (GET) creates `EnvironmentalAnalysisForm`. 4. Renders `intelligence.html` with the form. | HTTP GET request. Form instance -> Template context. | Page displays a form for selecting date range and instruments. Chart/analysis areas are hidden. | Batch 6 |
| Submit Analysis Query (Generate Charts) | `templates/fluke_data/intelligence.html` ('Filtrar' button), `static/js/intelligence.js` (`getChartData`), `/api/v1/environmental-analysis/out-of-limits-chart/` API endpoint (`api.views.environmental_analysis.EnvironmentalAnalysisView` - *Inferred*) | 1. User selects criteria, clicks 'Filtrar'. 2. JS intercepts submit, calls `getChartData`. 3. JS sends POST to API with form data. 4. API processes data, calculates stats, formats for charts. 5. API returns JSON. 6. JS (`showCharts`) uses ApexCharts to render bar, temperature, and humidity line charts. | Click event -> JS. POST request (JSON: date/time range, instruments) -> API. API response (JSON: chart data) -> JS -> ApexCharts rendering. | Charts are displayed below the form showing out-of-limits percentage, temperature trends, and humidity trends for the selected period and instruments. | Batch 6 |
| Submit Analysis Query (AI Analysis - Inactive) | `templates/fluke_data/intelligence.html`, `static/js/intelligence.js` (`getAnalysis`), `/api/v1/environmental-analysis/analyze-with-ai/` API endpoint (`api.views.crew_analysis.CrewAnalysisView` - *Inferred*), `crews/crew.py` (`AnalyticalCrewFlow`), External AI Service (`ANALYSIS_API_URL`) | *(Note: `getAnalysis` call is commented out in JS)* 1. (If enabled) JS calls `getAnalysis`. 2. JS sends POST to `analyze-with-ai` API. 3. API view triggers `AnalyticalCrewFlow`. 4. Flow makes sequential POST requests to external AI service endpoints (temp, humidity, productivity, report). 5. External service performs analysis. 6. Final report returned by external service -> Flow -> API view -> JS. 7. JS (`populateCard`) displays report. | Click event -> JS. POST request (JSON: date/time range, instruments) -> API. API -> `AnalyticalCrewFlow`. Flow -> Multiple POST requests (JSON data) -> External AI Service. External AI Service -> Responses -> Flow. Final Report (JSON) -> API -> JS -> HTML card. | (If enabled) A text-based analysis report (title, summary, analytics, suggestion, conclusion) is displayed in a card below the charts after processing by the external AI service. | Batch 6 |
| View Thermohygrometers | `/manage-thermohygrometers/` URL, `views.ManageThermohygrometersView`, `models.ThermohygrometerModel`, `templates/fluke_data/manage_thermohygrometers.html` | 1. User navigates to URL. 2. View fetches all thermohygrometers. 3. Renders template with thermohygrometers context. | HTTP GET request. DB query -> List of thermohygrometers -> Template context. | Page displays a table of thermohygrometers with actions for editing, managing sensors, and deleting. | Batch 7 |
| Edit Thermohygrometer | `/update-thermohygrometer/<id>/` URL, `views.UpdateThermohygrometerView`, `models.ThermohygrometerModel`, `forms.ThermohygrometerForm`, `templates/fluke_data/thermohygrometer/update_thermohygrometer.html` | 1. User navigates to URL. 2. View fetches thermohygrometer by ID. 3. Renders form pre-filled with thermohygrometer details. 4. User submits form. 5. View validates and updates thermohygrometer. | HTTP GET/POST request. DB query -> Thermohygrometer object. Form data -> DB update. | Thermohygrometer updated in DB. User redirected to list view with success message. | Batch 7 |
| View Sensors | `/manage-sensors/<thermohygrometer_id>/` URL, `views.ManageSensorsView`, `models.SensorModel`, `templates/fluke_data/sensor/manage_sensors.html` | 1. User navigates to URL. 2. View fetches sensors for the thermohygrometer. 3. Renders template with sensors context. | HTTP GET request. DB query -> List of sensors -> Template context. | Page displays a list of sensors for the selected thermohygrometer. | Batch 7 |
| Create Sensor | `/create-sensor/<thermohygrometer_id>/` URL, `views.CreateSensorView`, `models.SensorModel`, `forms.SensorForm`, `templates/fluke_data/sensor/create_sensor.html` | 1. User navigates to URL. 2. View renders empty form. 3. User submits form. 4. View validates and creates sensor, associating it with the thermohygrometer. | HTTP GET/POST request. Form data -> DB insert. | Sensor created in DB. User redirected to sensor list view with success message. | Batch 7 |
| Edit Sensor | `/update-sensor/<id>/` URL, `views.UpdateSensorView`, `models.SensorModel`, `forms.SensorForm`, `templates/fluke_data/sensor/update_sensor.html` | 1. User navigates to URL. 2. View fetches sensor by ID. 3. Renders form pre-filled with sensor details. 4. User submits form. 5. View validates and updates sensor. | HTTP GET/POST request. DB query -> Sensor object. Form data -> DB update. | Sensor updated in DB. User redirected to sensor list view with success message. | Batch 7 |
| Delete Sensor | `/delete-sensor/<id>/` URL, `views.DeleteSensorView`, `models.SensorModel`, `templates/fluke_data/sensor/delete_sensor.html` | 1. User navigates to URL. 2. View fetches sensor by ID. 3. User confirms deletion. 4. View deletes sensor. | HTTP GET/POST request. DB query -> Sensor object. DB delete. | Sensor deleted from DB. User redirected to sensor list view with success message. | Batch 7 |
| View Certificates List | `/manage-certificates/` URL, `views.ManageCertificatesView`, `templates/fluke_data/certificate/manage_all_certificates.html` (JS `loadCertificates`), `/api/v1/certificates/` API endpoint (`api.views.certificate.CertificateListView` - *Inferred*) | 1. User navigates to URL. 2. `ManageCertificatesView` renders template. 3. JS `loadCertificates` fetches data from API. 4. JS populates table rows with certificate data, Edit links (to Django view), and Delete buttons (JS action). | HTTP GET `/manage-certificates/`. HTTP GET `/api/v1/certificates/`. API response (JSON list) -> JS -> HTML table. | Page displays a table listing all calibration certificates. | Batch 8 |
| Create Certificate (Display Form) | `/create-certificate/` URL, `views.CreateCertificateView`, `forms.CalibrationCertificateForm`, `templates/fluke_data/certificate/create_certificate.html` | 1. User navigates to URL (e.g., via button on list page). 2. `CreateCertificateView` (GET) renders template with empty form. | HTTP GET request. Form instance -> Template context. | Page displays a form to enter details for a new calibration certificate. | Batch 8 |
| Create Certificate (Submit Form) | `/create-certificate/` URL, `views.CreateCertificateView`, `forms.CalibrationCertificateForm`, `models.CalibrationCertificateModel` | 1. User submits form. 2. `CreateCertificateView` (POST) validates data with form. 3. If valid: Saves new `CalibrationCertificateModel`, adds success message, redirects to `manage_all_certificates`. 4. If invalid: Re-renders form with errors. | HTTP POST request (form data). Form data -> DB insert. | Certificate created in DB. User redirected to list view with success message, or create form shown again with errors. | Batch 8 |
| Edit Certificate (Display Form) | `/edit-certificate/<id>/` URL, `views.UpdateCertificateView`, `forms.CalibrationCertificateForm`, `models.CalibrationCertificateModel`, `templates/fluke_data/certificate/edit_certificate.html` | 1. User navigates to URL (e.g., via Edit link on list page). 2. `UpdateCertificateView` (GET) fetches certificate by ID. 3. Renders template with pre-filled form. | HTTP GET request. Certificate ID (URL). DB query -> Certificate object -> Form initial data -> Template context. | Page displays a form pre-filled with the selected certificate's details. | Batch 8 |
| Edit Certificate (Submit Form) | `/edit-certificate/<id>/` URL, `views.UpdateCertificateView`, `forms.CalibrationCertificateForm`, `models.CalibrationCertificateModel` | 1. User submits form. 2. `UpdateCertificateView` (POST) validates data with form. 3. If valid: Updates certificate in DB, adds success message, redirects to `manage_all_certificates`. 4. If invalid: Re-renders form with errors. | HTTP POST request (form data). Certificate ID (URL). Form data -> DB update. | Certificate updated in DB. User redirected to list view with success message, or edit form shown again with errors. | Batch 8 |
| Delete Certificate | `manage_all_certificates.html` ('Delete' button), JS `deleteCertificate`, `/api/v1/certificates/<id>/` API endpoint (`api.views.certificate.CertificateDetailView` - *Inferred*) | 1. User clicks 'Delete' button. 2. JS prompts for confirmation. 3. If confirmed: JS sends DELETE request to API endpoint. 4. API deletes certificate. 5. JS calls `loadCertificates` to refresh the list. | Click event -> JS. Confirmation prompt. DELETE request -> API. API -> DB delete. API response -> JS -> `loadCertificates` call. | Certificate deleted from DB. List view refreshed to remove the deleted certificate. | Batch 8 |
| View User List                  | `/manage-users/` URL (Assumed), `urls.py`, `views.ManageUsersView`, `models.User`, `templates/fluke_data/user/manage_users.html`, `LoginRequiredMixin`, `ManagerRequiredMixin` | Manager navigates to URL. Mixins verify auth/manager status. View fetches all `User` objects. Renders template with `users` context. | HTTP GET. User session (auth). DB query -> List of users -> Template context. | Page displays a table/list of registered users with options to edit/delete. | Batch 9 |
| Create User (Display Form)    | `/create-user/` URL (Assumed), `urls.py`, `views.CreateUserView`, `forms.CreateUserForm`, `templates/fluke_data/user/create_user.html`, `LoginRequiredMixin`, `ManagerRequiredMixin` | Manager navigates to URL. Mixins verify auth/manager status. View (GET) renders template with an empty `CreateUserForm`. | HTTP GET. User session (auth). Form instance -> Template context. | Page displays a form to enter details for a new user (name, username, email, password, manager status). | Batch 9 |
| Create User (Submit Form)     | `/create-user/` URL (Assumed), `urls.py`, `views.CreateUserView`, `forms.CreateUserForm`, `models.User`, `LoginRequiredMixin`, `ManagerRequiredMixin` | Manager submits form. View (POST) validates data with `CreateUserForm`. If valid: Saves new `User` (password hashed), redirects to `manage_users`. If invalid: Re-renders form with errors. | HTTP POST (form data). User session (auth). Form data -> DB insert (`User` model). | New user created in DB. Redirected to user list page. Or create form shown again with errors. | Batch 9 |
| Update User (Display Form)    | `/update-user/<pk>/` URL (Assumed), `urls.py`, `views.UpdateUserView`, `forms.UpdateUserForm`, `models.User`, `templates/fluke_data/user/update_user.html`, `LoginRequiredMixin`, `ManagerRequiredMixin` | Manager navigates to URL. Mixins verify auth/manager status. View (GET) fetches user by primary key (`pk`). Renders template with pre-filled `UpdateUserForm` (excluding password). | HTTP GET. User ID (URL). User session (auth). DB query (`User`) -> User object -> Form initial data -> Template context. | Page displays a form pre-filled with the selected user's details (name, username, email, manager status), plus fields for optional password change. | Batch 9 |
| Update User (Submit Form)     | `/update-user/<pk>/` URL (Assumed), `urls.py`, `views.UpdateUserView`, `forms.UpdateUserForm`, `models.User`, `LoginRequiredMixin`, `ManagerRequiredMixin`, `django.contrib.auth.hashers.make_password`, `django.contrib.messages` | Manager submits form. View (POST) validates data with `UpdateUserForm`. If valid: Updates user fields. If `new_password1` is provided and matches `new_password2`, hashes and updates password. Saves `User`. Adds success message. Redirects to `manage_users`. If invalid: Re-renders form with errors. | HTTP POST (form data). User ID (URL). User session (auth). Form data -> DB update (`User` model). Password -> Hashing -> DB update. Success message. | User record updated in DB. Redirected to user list page with success message. Or update form shown again with errors. | Batch 9 |
| Delete User (Display Confirmation) | `/delete-user/<pk>/` URL (Assumed), `urls.py`, `views.DeleteUserView`, `models.User`, `templates/fluke_data/user/delete_user.html`, `LoginRequiredMixin`, `ManagerRequiredMixin` | Manager navigates to URL. Mixins verify auth/manager status. View (GET) fetches user by `pk`. Renders template asking for confirmation, displaying username. | HTTP GET. User ID (URL). User session (auth). DB query (`User`) -> User object -> Template context. | Confirmation page displayed asking if the user wants to delete the specified user. | Batch 9 |
| Delete User (Confirm Deletion) | `/delete-user/<pk>/` URL (Assumed), `urls.py`, `views.DeleteUserView`, `models.User`, `LoginRequiredMixin`, `ManagerRequiredMixin` | Manager submits confirmation. View (POST) fetches user by `pk` and deletes the `User` object. Redirects to `manage_users`. | HTTP POST. User ID (URL). User session (auth). DB delete (`User` model). | User record deleted from DB. Redirected to user list page. | Batch 9 |

---

*   **User Action:** The specific interaction the user performs with the interface.
*   **Components Involved:** The code files, classes, functions, templates, or database models participating in the process.
*   **Process:** The sequence of internal operations triggered by the user action.
*   **Data Flow:** How data is passed between components (e.g., form data, API responses, WebSocket messages, database records).
*   **Outcome / User Feedback:** The observable result for the user (e.g., UI change, data displayed, error message) or the final state change in the system.
*   **Analysis Batch:** The batch number from `phase_1_summary.md` where this relationship was primarily identified.